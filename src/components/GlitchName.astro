---
interface Props {
  initialName?: string;
  finalName?: string;
  initialDelay?: number;
  glitchDuration?: number;
  typeSpeed?: number;
  deleteSpeed?: number;
  class?: string;
}

const {
  initialName = "Roselie Freixas",
  finalName = "TheRivetedRose",
  initialDelay = 500,
  glitchDuration = 600,
  typeSpeed = 120,
  deleteSpeed = 40,
  class: className = "text-rosie-red",
} = Astro.props;
---

<span
  class:list={[className]}
  data-glitch-name
  data-initial={initialName}
  data-final={finalName}
  data-initial-delay={initialDelay}
  data-glitch-duration={glitchDuration}
  data-type-speed={typeSpeed}
  data-delete-speed={deleteSpeed}
>

</span>

<style>
  .glitch-active {
    animation: glitch-flicker 0.1s steps(2) infinite;
  }

  @keyframes glitch-flicker {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.85;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .glitch-active {
      animation: none;
    }
  }
</style>

<script>
  const GLITCH_CHARS = "!@#$%^&*01[]{}|/~`";

  function initGlitchName() {
    const el = document.querySelector("[data-glitch-name]");
    if (!el) return;

    const initial =
      el.getAttribute("data-initial") ?? "Roselie Freixas";
    const final = el.getAttribute("data-final") ?? "TheRivetedRose";
    const initialDelay = parseInt(
      el.getAttribute("data-initial-delay") ?? "1200",
      10
    );
    const glitchDuration = parseInt(
      el.getAttribute("data-glitch-duration") ?? "600",
      10
    );
    const typeSpeed = parseInt(
      el.getAttribute("data-type-speed") ?? "60",
      10
    );
    const deleteSpeed = parseInt(
      el.getAttribute("data-delete-speed") ?? "40",
      10
    );

    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      const htmlEl = el as HTMLElement;
      htmlEl.style.transition = "opacity 0.6s ease";

      function typeInitialReduced(callback: () => void) {
        htmlEl.textContent = "";
        let idx = 0;
        function typeNext() {
          htmlEl.textContent = initial.slice(0, idx + 1);
          idx++;
          if (idx < initial.length) {
            setTimeout(typeNext, typeSpeed);
          } else {
            setTimeout(callback, 400);
          }
        }
        setTimeout(typeNext, initialDelay);
      }

      typeInitialReduced(() => {
        htmlEl.style.opacity = "0";
        setTimeout(() => {
          htmlEl.textContent = final;
          htmlEl.style.opacity = "1";
        }, 600);
      });

      document.addEventListener("glitch-name-trigger", () => {
        htmlEl.style.opacity = "0";
        setTimeout(() => {
          htmlEl.textContent = initial;
          htmlEl.style.opacity = "1";
          setTimeout(() => {
            htmlEl.style.opacity = "0";
            setTimeout(() => {
              htmlEl.textContent = final;
              htmlEl.style.opacity = "1";
              document.dispatchEvent(new CustomEvent("glitch-name-complete"));
            }, 600);
          }, 1400);
        }, 600);
      });
      return;
    }

    function randomChar() {
      return GLITCH_CHARS[Math.floor(Math.random() * GLITCH_CHARS.length)];
    }

    function scramble(str: string, intensity: number): string {
      return str
        .split("")
        .map((c) =>
          c === " " ? " " : Math.random() < intensity ? randomChar() : c
        )
        .join("");
    }

    function runGlitch(callback?: () => void) {
      el!.classList.add("glitch-active");
      const iterations = Math.max(10, Math.floor(glitchDuration / 50));
      const interval = glitchDuration / iterations;
      let count = 0;

      const glitchInterval = setInterval(() => {
        count++;
        const progress = count / iterations;
        if (progress < 0.5) {
          el!.textContent = scramble(initial, progress * 1.2);
        } else if (progress < 0.85) {
          el!.textContent = scramble(final, (1 - progress) * 1.5);
        } else {
          el!.textContent = final;
        }

        if (count >= iterations) {
          clearInterval(glitchInterval);
          el!.classList.remove("glitch-active");
          el!.textContent = final;
          callback?.();
        }
      }, interval);
    }

    function runLoopCycle() {
      if (!el) return;
      el.textContent = final;
      let idx = final.length;

      function deleteNext() {
        idx--;
        el!.textContent = final.slice(0, idx);
        if (idx > 0) {
          setTimeout(deleteNext, deleteSpeed);
        } else {
          idx = 0;
          typeNext();
        }
      }

      function typeNext() {
        el!.textContent = initial.slice(0, idx + 1);
        idx++;
        if (idx < initial.length) {
          setTimeout(typeNext, typeSpeed);
        } else {
          setTimeout(() => {
            runGlitch(() => {
              document.dispatchEvent(new CustomEvent("glitch-name-complete"));
            });
          }, 300);
        }
      }

      setTimeout(deleteNext, 200);
    }

    document.addEventListener("glitch-name-trigger", runLoopCycle);

    function typeInitial(callback: () => void) {
      el!.textContent = "";
      let idx = 0;
      function typeNext() {
        el!.textContent = initial.slice(0, idx + 1);
        idx++;
        if (idx < initial.length) {
          setTimeout(typeNext, typeSpeed);
        } else {
          setTimeout(callback, 400);
        }
      }
      setTimeout(typeNext, initialDelay);
    }

    typeInitial(() => runGlitch());
  }

  initGlitchName();
</script>
