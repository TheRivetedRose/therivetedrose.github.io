---
interface Props {
  phrases: string[];
  subheadlines?: string[];
  class?: string;
}

const { phrases, subheadlines = [], class: className } = Astro.props;
const firstPhrase = phrases[0] ?? "";
const firstSubheadline = subheadlines[0] ?? "";
---

<div
  class:list={[className]}
  data-typewriter
  data-phrases={JSON.stringify(phrases)}
  data-subheadlines={JSON.stringify(subheadlines)}
>
  <span data-typewriter-phrase>{firstPhrase}</span>
  {
    subheadlines.length > 0 && (
      <p class="mt-2 text-base text-muted" data-typewriter-subheadline>
        {firstSubheadline}
      </p>
    )
  }
</div>

<script>
  function initTypewriter() {
    const container = document.querySelector("[data-typewriter]");
    const phraseEl = container?.querySelector("[data-typewriter-phrase]");
    const subheadlineEl = container?.querySelector(
      "[data-typewriter-subheadline]",
    );
    if (!phraseEl) return;

    let phrases: string[];
    let subheadlines: string[];
    try {
      phrases = JSON.parse(container?.getAttribute("data-phrases") ?? "[]");
      subheadlines = JSON.parse(
        container?.getAttribute("data-subheadlines") ?? "[]",
      );
    } catch {
      return;
    }
    if (phrases.length < 2) return;

    const hasSubheadlines = subheadlines.length > 0;
    const minPhraseDelay = 1500;

    let phraseIndex = 0;
    let phraseCharIndex = 0;
    let subheadlineCharIndex = 0;
    let phase: "phrase" | "subheadline" | "deletingSubheadline" | "pause" =
      "phrase";
    let isDeletingPhrase = false;

    const phraseTypeSpeed = 80;
    const phraseDeleteSpeed = 50;
    const subheadlineTypeSpeed = 70;
    const subheadlineDeleteSpeed = 40;

    function run() {
      const currentPhrase = phrases[phraseIndex] ?? "";
      const currentSubheadline = hasSubheadlines
        ? (subheadlines[phraseIndex] ?? "")
        : "";

      if (phase === "phrase") {
        if (isDeletingPhrase) {
          phraseEl!.textContent = currentPhrase.slice(0, phraseCharIndex - 1);
          phraseCharIndex--;
          if (phraseCharIndex === 0) {
            isDeletingPhrase = false;
            phraseIndex = (phraseIndex + 1) % phrases.length;
            phase = "phrase";
            setTimeout(run, 500);
            return;
          }
          setTimeout(run, phraseDeleteSpeed);
        } else {
          phraseEl!.textContent = currentPhrase.slice(0, phraseCharIndex + 1);
          phraseCharIndex++;
          if (phraseCharIndex === currentPhrase.length) {
            if (hasSubheadlines && currentSubheadline) {
              phase = "subheadline";
              subheadlineCharIndex = 0;
              if (subheadlineEl) subheadlineEl.textContent = "";
              setTimeout(run, 200);
            } else {
              phase = "pause";
              setTimeout(run, minPhraseDelay);
            }
            return;
          }
          setTimeout(run, phraseTypeSpeed);
        }
        return;
      }

      if (phase === "subheadline") {
        const nextSubheadline = subheadlines[phraseIndex] ?? "";
        if (subheadlineEl) {
          subheadlineEl.textContent = nextSubheadline.slice(
            0,
            subheadlineCharIndex + 1,
          );
        }
        subheadlineCharIndex++;
        if (subheadlineCharIndex >= nextSubheadline.length) {
          phase = "pause";
          setTimeout(run, minPhraseDelay);
          return;
        }
        setTimeout(run, subheadlineTypeSpeed);
        return;
      }

      if (phase === "deletingSubheadline") {
        const nextSubheadline = subheadlines[phraseIndex] ?? "";
        if (subheadlineEl) {
          subheadlineEl.textContent = nextSubheadline.slice(
            0,
            subheadlineCharIndex - 1,
          );
        }
        subheadlineCharIndex--;
        if (subheadlineCharIndex <= 0) {
          if (subheadlineEl) subheadlineEl.textContent = "";
          subheadlineCharIndex = 0;
          isDeletingPhrase = true;
          phase = "phrase";
          setTimeout(run, 500);
          return;
        }
        setTimeout(run, subheadlineDeleteSpeed);
        return;
      }

      if (phase === "pause") {
        if (hasSubheadlines && subheadlineEl) {
          phase = "deletingSubheadline";
          subheadlineCharIndex = (subheadlines[phraseIndex] ?? "").length;
          setTimeout(run, 200);
        } else {
          isDeletingPhrase = true;
          phase = "phrase";
          setTimeout(run, 500);
        }
      }
    }

    setTimeout(run, 500);
  }

  initTypewriter();
</script>
